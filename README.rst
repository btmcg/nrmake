nrmake
======

A `non-recursive make
<https://web.archive.org/web/20070205211740/http://aegis.sourceforge.net/auug97.pdf>`_
build system designed with two goals in mind: minimalism and efficiency.
Supports C and C++ projects using gcc and/or clang. The only dependency
required is GNU Make of at least v3.82.

See the `nrmake-example repository
<https://gitlab.com/btmcg/nrmake-example.git>`_ for an example of how to
use this build system.

For each "module" (i.e.,executable, static lib, shared lib) you want to
build, you simply need to create a file called ``Module.mk`` in the
directory. The simplest ``Module.mk`` requires a single line.


example ``Module.mk``
---------------------

.. code-block:: make

    $(call add-executable-module,$(call get-path))


This builds an executable with the same name as the directory and puts
it in the ``<root>/bin`` directory. For documentation on how to provide
individual ``CPPFLAGS``, ``LDFLAGS``, ``CXXFLAGS``, etc., see
``nrmake/module_example.mk``.


how to use nrmake in your project
---------------------------------

The best way to use nrmake in your project is to include it as a git
submodule. From your project's root directory, do the following:

.. code-block::

    git submodule add -- https://gitlab.com/btmcg/nrmake.git
    cd nrmake
    git checkout -b v1.00
    cd ..
    cp nrmake/example_makefile Makefile

Then add ``Module.mk`` files to the directory of each executable or
library you would like to build. See the example one-line file cited
above or use `nrmake-example
<https://gitlab.com/btmcg/nrmake-example.git>`_ as an example. A
description of all supported variables are listed in module_example.mk.


project structure
-----------------

``<root>/benchmark/``
    Project benchmarking code, ideally for use with `google-benchmark
    <https://github.com/google/benchmark>`_.

``<root>/nrmake/``
    Build-related makefiles, provided by this repository.

``<root>/src/``
    Project source code.

``<root>/test/``
    Project unit testing code, ideally for use with `catch
    <https://github.com/catchorg/Catch2>`_.

``<root>/third_party/``
    Third party dependencies for project, including catch and
    google-benchmark libraries. The goal being to keep the entire
    project self-contained.

``<root>/bin/``
    Final location of all of the project's compiled executables.

``<root>/lib/``
    Final location of all of the project's compiled libraries.


supported build options
-----------------------

``DEBUG``
    Disables optimizations and removes the ``NDEBUG`` flag. By default,
    all compile- and link-time optimizations are turned on and
    ``-DNDEBUG`` is set.

``COMPILER``
    Supports either ``clang`` or ``gcc`` (default ``gcc``).

``ASAN``
    Compiles with address sanitization static analysis.

``MSAN``
    Compiles with memory sanitization static analysis (currently only
    supported by ``clang``).

``UBSAN``
    Compiles with undefined behavior sanitization static analysis.

``PGO_GEN``
    Builds binaries with profile-guided optimization instrumentation.
    The profile data will be written after running a compiled binary.

``PGO_USE``
    Uses the profile data generated by ``PGO_GEN=1``.


example usage
-------------

``make -j``
    Builds the tree using ``gcc`` with full optimizations and places all
    binaries and libraries in ``bin/`` and ``lib/``.

``make COMPILER=clang DEBUG=1 -j``
    Builds the tree using clang with optimizations turned off.

``make tidy``
    Runs ``clang-tidy`` on the source tree.

``make benchmark``
    Builds the benchmarking code and executes ``bin/benchmark-runner``.

``make COMPILER=clang DEBUG=1 ASAN=1 test -j``
    Builds the testing code with clang and address sanitization turned on.


default targets
---------------

``all``
    Builds every module in the tree, including the "special" targets ``test-runner`` and ``benchmark-runner``. This is built by default when no arguments are given to ``make``.

``benchmark``
    Builds (if necessary) the benchmarking code (assuming google-benchmark has been installed) and executes ``bin/benchmark-runner``.

``clean``
    Removes all build artifacts from the tree; this includes: object code, dependency files, libraries, and executables. Top-level ``bin/`` and ``lib/`` directories are preserved.

``distclean``
    Removes everything that ``clean`` does, however it includes ``bin/`` and ``lib/``.

``format``
    Runs ``clang-format`` on ``src/``, ``test/``, and ``benchmark`` directories. (Assumes a ``.clang-format`` file exists in root.

``list-modules``
    Prints to stdout every module the build system is aware of, along with its associated build and link flags.

``tags``
    Runs ctags on the ``src/`` directory.

``test``
    Builds (if necessary) the unit testing code (assuming catch is installed) and executes ``bin/test-runner``.

``tidy``
    Runs ``clang-tidy`` on ``src/``. (Assumes a ``.clang-tidy`` file exists in root.


third-party libraries
---------------------

nrmake was designed with `catch <https://github.com/catchorg/Catch2>`_
and `google-benchmark <https://github.com/google/benchmark>`_ in mind.
Including these two projects is fairly simple.

catch
~~~~~
catch is best included as a submodule with your project's test code in
``<root>/test``. To make the header available to your code, an edit of
``nrmake/third_party.mk`` is required. Boilerplate provided.

.. code-block::

    git submodule add -- https://gitlab.com/catchorg/Catch2.git third_party/catch2/2.12.2
    cd third_party/catch2/2.12.2
    git checkout -b v2.12.2
    vim nrmake/third_party.mk

google-benchmark
~~~~~~~~~~~~~~~~
google-benchmark needs to be compiled for both ``gcc`` and ``clang``.
The following steps will install the header and libraries in separate
directories under ``<root>/third_party``. To make the library available
to your code, an edit of ``nrmake/third_party.mk`` is required. Boilerplate
is provided.

.. code-block::

    # from your repository root
    git clone --branch=v1.5.0 --depth=1 https://github.com/google/benchmark.git gb
    cd gb

    cmake . -DBENCHMARK_ENABLE_GTEST_TESTS=OFF -DBENCHMARK_ENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DCMAKE_INSTALL_PREFIX=../third_party/google-benchmark-gcc/1.5.0
    make install -j

    # now build with clang
    rm -rf CMakeFiles src/generated

    cmake . -DBENCHMARK_ENABLE_GTEST_TESTS=OFF -DBENCHMARK_ENABLE_TESTING=OFF -DBENCHMARK_USE_LIBCXX=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=/usr/bin/clang++ -DCMAKE_INSTALL_PREFIX=../third_party/google-benchmark-clang/1.5.0
    make install -j

    cd ..
    rm -rf gb
    vim nrmake/third_party.mk


rationale
---------

After years of using less-than-efficient build systems (GNU Make-based
or otherwise) in various jobs and personal projects, I wanted to create
a simple environment that I could replicate over and over again that
would do exactly what I needed it to do. I wanted it to use make (due to
its ubiquity), require zero dependencies, build binaries or libraries,
correctly handle internal dependency graphs, and provide a mechanism for
running unit tests and benchmarks. I didn't want to waste time thinking
about how to build and structure the code and tests, I just wanted to
get some prototype on the disk. What started as a Makefile that I would
copy to each new project turned into more of a "system" (collection of
.mk files) that provided various features that I used on a regular
basis. I finally decided to make this repo public, write this README,
and provide this code for anyone else like me that has suffered with
clumsy C++ build systems in the past.
